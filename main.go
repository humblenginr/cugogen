package main

import (
	"bytes"
	"cuelang.org/go/cue"
	"cuelang.org/go/cue/cuecontext"
	"cuelang.org/go/cue/load"
	"fmt"
	"go/format"
	"os"
	"strings"
)

const DefGenerationAttr = "generate"

func main() {
	w := &writer{}
	structsToGenerate := make(map[string]cue.Value)
	// load the cue instances
	instancePath := "./..."

	if len(os.Args) > 1 {
		instancePath = os.Args[1] + "/..."
	}
	bis := load.Instances([]string{instancePath}, &load.Config{})
	cueCtx := cuecontext.New()
	val, err := cueCtx.BuildInstances(bis)
	// make sure that we have structs
	s, err := val[0].Struct()
	if err != nil {
		fmt.Println(err)
		return
	}
	iter := s.Fields(
		cue.Attributes(true),
		cue.Definitions(true),
		cue.Optional(true),
	)

	for iter.Next() {
		attrs := iter.Value().Attributes(cue.DeclAttr)
		for _, attr := range attrs {
			if attr.Name() == DefGenerationAttr {
				if _, err := iter.Value().Struct(); err == nil {
					structsToGenerate[iter.Label()] = iter.Value()
				}
			}
		}
	}

	w.structsToGenerate = structsToGenerate
	w.rootVal = val[0]
	// fmt.Println(structsToGenerate)
	w.generate()

}

func getGoType(val cue.Value, refMap map[string]string) string {
	switch val.IncompleteKind() {
	case cue.BottomKind:
		return "interface{}"
	case cue.TopKind:
		return "interface{}"
	case cue.StringKind:
		return "string"
	case cue.FloatKind:
		return "float"
	case cue.IntKind:
		return "int"
	case cue.BoolKind:
		return "bool"
	case cue.ListKind:
		list, err := val.List()
		if err != nil {
			return "[]"
		}
		for list.Next() {
			return "[]" + getGoType(list.Value(), refMap)
		}
	case cue.StructKind:
		s, _ := val.Struct()
		if s.Len() == 0 {
			return "map[string]interface{}"
		}
		result := "struct{\n"
		i, err := val.Fields(cue.Optional(true))
		if err != nil {
			return ""
		}
		for i.Next() {
			dispLabel := strings.Title(i.Label())
			result = result + "\t  " + dispLabel
			if structName, ok := refMap[i.Label()]; ok {
				if i.Value().IncompleteKind() != cue.ListKind {
					result = result + " " + structName + "\n"
					continue
				} else {
					result = result + " []" + structName + "\n"
					continue
				}
			}
			result = result + " " + getGoType(i.Value(), refMap) + "\n"
		}
		result = result + "\t}\n"
		return result
	}
	return ""
}

type writer struct {
	writtenStructs    []string
	structsToGenerate map[string]cue.Value
	rootVal           cue.Value
	resultBuffer      bytes.Buffer
}

func (w *writer) generate() {
	w.resultBuffer.WriteString("// THIS FILE IS AUTOGENERATED BY CUGOGEN.\n")
	pkg := os.Getenv("GOPACKAGE")
	if pkg == "" {
		pkg = "main"
	}
	w.resultBuffer.WriteString("package " + pkg + "\n\n\n")
	for _, val := range w.structsToGenerate {
		m, err := findReferencedValuesStruct(val)
		if err != nil {
			fmt.Println(err)
			return
		}
		for _, path := range m {
			w.generateStruct(path, w.rootVal.LookupPath(cue.ParsePath(path)), nil)
		}
		if label, ok := val.Label(); ok {
			w.generateStruct(label, val.Value(), m)
		}
	}

	file, err := os.Create("./cue_types.go")
	if err != nil {
		fmt.Println(err)
	}
	formattedResult, err := format.Source(w.resultBuffer.Bytes())
	if err != nil {
		formattedResult = w.resultBuffer.Bytes()
	}
	file.Write(formattedResult)
	if err != nil {
		fmt.Println(err)
	}
}

func (w *writer) generateStruct(name string, value cue.Value, refMap map[string]string) {
	for _, v := range w.writtenStructs {
		if v == name {
			return
		}
	}

	i, err := value.Fields(cue.Optional(true))
	if err != nil {
		return
	}
	// generate struct

	name = strings.Title(name)
	_, _ = w.resultBuffer.WriteString(fmt.Sprintf("type %s struct{\n", name))

	for i.Next() {
		dispLabel := strings.Title(i.Label())
		if structName, ok := refMap[i.Label()]; ok {
			_, _ = w.resultBuffer.WriteString(fmt.Sprintf("\t%s %s\n", dispLabel, structName))
			continue
		}
		_, _ = w.resultBuffer.WriteString(fmt.Sprintf("\t%s %s\n", dispLabel, getGoType(i.Value(), refMap)))
	}
	_, _ = w.resultBuffer.WriteString(fmt.Sprintf("}\n"))

	w.writtenStructs = append(w.writtenStructs, name)
}

func findReferencedValuesStruct(val cue.Value) (map[string]string, error) {
	lablePathsMap := make(map[string]string)
	// make sure that it is a struct
	iter, err := val.Fields(cue.Optional(true))
	if err != nil {
		return lablePathsMap, err
	}
	for iter.Next() {
		if _, err := iter.Value().Struct(); err == nil {
			prMaps, err := findReferencedValuesStruct(iter.Value())
			if err == nil {
				for l, p := range prMaps {
					lablePathsMap[l] = p
				}
			}
		}

		if i, err := iter.Value().List(); err == nil {
			for i.Next() {
				_, path := i.Value().ReferencePath()
				if pathStr := path.String(); pathStr != "" {
					lablePathsMap[iter.Label()] = path.String()
				}
			}
		}

		_, path := iter.Value().ReferencePath()
		if pathStr := path.String(); pathStr != "" {
			lablePathsMap[iter.Label()] = path.String()
		}
	}

	return lablePathsMap, nil
}
